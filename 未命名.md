
 展形ERP财务结算方案设计（修订版 v4）

 概述

 基于白板分析和现有系统架构，在复用现有 financial 体系的基础上，扩展支持展形钢材贸易的垫资结算场景。

 ---
 〇、口径定义与技术决策（已采用默认值）

 ✅ 以下口径已采用默认值，可直接开始开发；后续可通过配置表调整[[未命名]]

 0.1 垫资利息口径（采用默认值，可后续调整）

 决策：采用以下默认值启动开发，后续可通过配置表调整

 ┌──────────┬──────────┬───────────────────────────────────┐
 │   参数   │  确定值  │               说明                │
 ├──────────┼──────────┼───────────────────────────────────┤
 │ 计息基数 │ 含税金额 │ 垫资本金 = 采购含税金额           │
 ├──────────┼──────────┼───────────────────────────────────┤
 │ 利率换算 │ 年化/360 │ 日利率 = 年化利率 / 360           │
 ├──────────┼──────────┼───────────────────────────────────┤
 │ 计息起日 │ 付款日   │ advanceStartDate                  │
 ├──────────┼──────────┼───────────────────────────────────┤
 │ 计息止日 │ 回款日   │ advanceEndDate                    │
 ├──────────┼──────────┼───────────────────────────────────┤
 │ 天数计算 │ 自然日   │ advanceDays = endDate - startDate │
 ├──────────┼──────────┼───────────────────────────────────┤
 │ 向上取整 │ 否       │ 不足一天按实际天数                │
 ├──────────┼──────────┼───────────────────────────────────┤
 │ 阶梯规则 │ 无       │ 单一利率，不分阶梯                │
 ├──────────┼──────────┼───────────────────────────────────┤
 │ 封顶规则 │ 无       │ 无利息上限                        │
 ├──────────┼──────────┼───────────────────────────────────┤
 │ 跨期处理 │ 统一利率 │ 不分段，按统一利率计算            │
 ├──────────┼──────────┼───────────────────────────────────┤
 │ 年化利率 │ 18%      │ 自有资金垫资（可配置）            │
 └──────────┴──────────┴───────────────────────────────────┘
 利息计算公式：
 利息 = 垫资金额(含税) × 年化利率 / 360 × 垫资天数

 其中：
 - 垫资天数 = endDate - startDate（自然日差，不含首日含末日）
 - 数值精度：金额保留2位，日利率存6位
 - 舍入模式：BigDecimal.ROUND_HALF_UP

 天数边界处理：
 - 同日（startDate == endDate）→ 天数=0，利息=0
 - 起日>止日 → 校验拒绝，抛出异常
 - 跨月/跨年 → 正常计算自然日差

 验收算例（5个）：
 ┌──────┬────────────────┬──────────┬──────────┬──────┬──────────────────────────────┬────────────┐
 │ 序号 │ 垫资金额(含税) │ 年化利率 │  起止日  │ 天数 │           利息计算           │    结果    │
 ├──────┼────────────────┼──────────┼──────────┼──────┼──────────────────────────────┼────────────┤
 │ 1    │ 1,000,000      │ 18%      │ 1/1-1/31 │ 30   │ 1,000,000 × 0.18 / 360 × 30  │ 15,000.00  │
 ├──────┼────────────────┼──────────┼──────────┼──────┼──────────────────────────────┼────────────┤
 │ 2    │ 1,000,000      │ 18%      │ 1/1-3/1  │ 60   │ 1,000,000 × 0.18 / 360 × 60  │ 30,000.00  │
 ├──────┼────────────────┼──────────┼──────────┼──────┼──────────────────────────────┼────────────┤
 │ 3    │ 500,000        │ 18%      │ 1/1-2/15 │ 45   │ 500,000 × 0.18 / 360 × 45    │ 11,250.00  │
 ├──────┼────────────────┼──────────┼──────────┼──────┼──────────────────────────────┼────────────┤
 │ 4    │ 2,000,000      │ 18%      │ 1/1-4/30 │ 120  │ 2,000,000 × 0.18 / 360 × 120 │ 120,000.00 │
 ├──────┼────────────────┼──────────┼──────────┼──────┼──────────────────────────────┼────────────┤
 │ 5    │ 800,000        │ 12%      │ 1/1-1/16 │ 15   │ 800,000 × 0.12 / 360 × 15    │ 4,000.00   │
 └──────┴────────────────┴──────────┴──────────┴──────┴──────────────────────────────┴────────────┘
 0.2 物流费用口径（手工录入模式）

 决策：物流费用采用手工录入模式，用户填写单价，系统计算金额

 费用录入模式说明：
 ┌────────────────────────────────────┬──────────────┬────────────────────────────────────────┐
 │              费用类型              │   录入模式   │                  说明                  │
 ├────────────────────────────────────┼──────────────┼────────────────────────────────────────┤
 │ 垫资利息                           │ 配置表取参   │ 从 financial_expense_config 读取利率   │
 ├────────────────────────────────────┼──────────────┼────────────────────────────────────────┤
 │ 通道费                             │ 配置表取参   │ 从 financial_expense_config 读取费率   │
 ├────────────────────────────────────┼──────────────┼────────────────────────────────────────┤
 │ 贴息                               │ 配置表取参   │ 从 financial_expense_config 读取贴息率 │
 ├────────────────────────────────────┼──────────────┼────────────────────────────────────────┤
 │ 船运费/港口费/仓储费/加工费/装卸费 │ 用户手工填写 │ 用户在费用明细中录入单价               │
 └────────────────────────────────────┴──────────────┴────────────────────────────────────────┘
 物流费用明细（手工录入）：
 ┌──────────┬─────────────────┬──────────┬────────────────────┬────────────┐
 │ 费用类型 │    计费基数     │ 单价来源 │        公式        │    说明    │
 ├──────────┼─────────────────┼──────────┼────────────────────┼────────────┤
 │ 船运费   │ 数量(吨)        │ 用户填写 │ 数量 × 单价        │ 按吨计费   │
 ├──────────┼─────────────────┼──────────┼────────────────────┼────────────┤
 │ 港口费   │ 数量(吨)        │ 用户填写 │ 数量 × 单价        │ 按吨计费   │
 ├──────────┼─────────────────┼──────────┼────────────────────┼────────────┤
 │ 仓储费   │ 数量(吨) × 天数 │ 用户填写 │ 数量 × 单价 × 天数 │ 按吨天计费 │
 ├──────────┼─────────────────┼──────────┼────────────────────┼────────────┤
 │ 加工费   │ 数量(吨)        │ 用户填写 │ 数量 × 单价        │ 按吨计费   │
 ├──────────┼─────────────────┼──────────┼────────────────────┼────────────┤
 │ 装卸费   │ 数量(吨)        │ 用户填写 │ 数量 × 单价        │ 按吨计费   │
 └──────────┴─────────────────┴──────────┴────────────────────┴────────────┘
 注意：物流费用不走配置表，用户直接在费用明细行中填写单价和数量，后端仅计算金额

 费用计算公式：
 普通费用 = 数量(吨) × 单价(元/吨)
 仓储费用 = 数量(吨) × 单价(元/吨/天) × 天数

 验收算例（5个）：
 ┌──────┬──────────┬──────────┬─────────────┬──────┬────────────────┬───────────┐
 │ 序号 │ 费用类型 │ 数量(吨) │    单价     │ 天数 │    金额计算    │   结果    │
 ├──────┼──────────┼──────────┼─────────────┼──────┼────────────────┼───────────┤
 │ 1    │ 船运费   │ 500      │ 50元/吨     │ -    │ 500 × 50       │ 25,000.00 │
 ├──────┼──────────┼──────────┼─────────────┼──────┼────────────────┼───────────┤
 │ 2    │ 港口费   │ 500      │ 15元/吨     │ -    │ 500 × 15       │ 7,500.00  │
 ├──────┼──────────┼──────────┼─────────────┼──────┼────────────────┼───────────┤
 │ 3    │ 仓储费   │ 500      │ 0.5元/吨/天 │ 30   │ 500 × 0.5 × 30 │ 7,500.00  │
 ├──────┼──────────┼──────────┼─────────────┼──────┼────────────────┼───────────┤
 │ 4    │ 加工费   │ 300      │ 80元/吨     │ -    │ 300 × 80       │ 24,000.00 │
 ├──────┼──────────┼──────────┼─────────────┼──────┼────────────────┼───────────┤
 │ 5    │ 装卸费   │ 500      │ 8元/吨      │ -    │ 500 × 8        │ 4,000.00  │
 └──────┴──────────┴──────────┴─────────────┴──────┴────────────────┴───────────┘
 0.3 与现有表的关系确认

 现有结构分析：
 - financial_settlement - 主表（继承 BaseBill，有 otherExpensesAmount 单一费用字段）
 - financial_settlement_detail - 商品明细表（SKU、数量、价格、税额）

 决策点：扩展现有表 vs 新建费用表
 ┌────────────────────────┬────────────────────┬────────────────────────────────────────────────┬────────┐
 │          方案          │        优点        │                      缺点                      │  建议  │
 ├────────────────────────┼────────────────────┼────────────────────────────────────────────────┼────────┤
 │ 方案A: 扩展 detail 表  │ 复用现有结构       │ 商品明细与费用明细混在一起，需加 type 字段区分 │ 不推荐 │
 ├────────────────────────┼────────────────────┼────────────────────────────────────────────────┼────────┤
 │ 方案B: 新建 expense 表 │ 职责清晰，独立管理 │ 需新增 Entity/Mapper/Service                   │ 推荐   │
 └────────────────────────┴────────────────────┴────────────────────────────────────────────────┴────────┘
 推荐方案B：新建 financial_settlement_expense 表
 - 与 financial_settlement_detail（商品明细）并行
 - 独立的费用类型字典
 - 主表 otherExpensesAmount 字段改为从 expense 表汇总计算

 0.4 现有 otherExpensesAmount 字段处理

 现状：
 - otherExpensesAmount 在 BaseBill 中定义，被 FinancialSettlement 继承
 - 当前为手工填写的单一合计字段
 - 公式：actualAmount = goodsAmount + otherExpensesAmount - discountAmount

 改造方案：
 ┌──────────┬──────────────┬───────────────────────┐
 │   项目   │    改造前    │        改造后         │
 ├──────────┼──────────────┼───────────────────────┤
 │ 数据来源 │ 手工填写     │ 从 expense 表自动汇总 │
 ├──────────┼──────────────┼───────────────────────┤
 │ 字段用途 │ 其他费用合计 │ 保留，作为汇总字段    │
 ├──────────┼──────────────┼───────────────────────┤
 │ 编辑方式 │ 直接编辑     │ 只读（自动计算）      │
 ├──────────┼──────────────┼───────────────────────┤
 │ 向后兼容 │ -            │ 旧数据保持不变        │
 └──────────┴──────────────┴───────────────────────┘
 Service 层改造：
 // 保存时自动计算 otherExpensesAmount
 public void saveExpenseList(Long settlementId, List<FinancialSettlementExpenseBo> expenseList) {
     // 1. 保存费用明细
     // ...

     // 2. 汇总费用到主表 otherExpensesAmount
     BigDecimal totalExpense = expenseList.stream()
         .map(FinancialSettlementExpenseBo::getAmount)
         .filter(Objects::nonNull)
         .reduce(BigDecimal.ZERO, BigDecimal::add);

     // 3. 更新主表（同时更新 otherExpensesAmount 和 totalExpenseAmount）
     baseMapper.update(null, Wrappers.<FinancialSettlement>lambdaUpdate()
         .eq(FinancialSettlement::getId, settlementId)
         .set(FinancialSettlement::getOtherExpensesAmount, totalExpense)
         .set(FinancialSettlement::getTotalExpenseAmount, totalExpense));

     // 4. actualAmount 在数据库触发器或应用层自动计算
 }

 前端改造：
 - otherExpensesAmount 字段改为只读展示
 - 用户通过费用明细 Tab 添加/编辑费用
 - 保存时后端自动汇总

 0.5 旧数据兼容与迁移策略

 向后兼容原则：
 - 已有单据的 otherExpensesAmount 保持不变
 - 新单据通过费用明细表计算
 - 不强制迁移旧数据

 数据迁移方案（可选）：
 -- 1. 查找有 otherExpensesAmount 但无费用明细的旧单据
 SELECT id, doc_no, other_expenses_amount
 FROM financial_settlement
 WHERE other_expenses_amount > 0
   AND del_flag = '0'
   AND id NOT IN (SELECT DISTINCT pid FROM financial_settlement_expense WHERE del_flag = '0');

 -- 2. 为旧数据创建"其他费用"明细（可选，手工执行）
 INSERT INTO financial_settlement_expense (pid, expense_type, expense_name, amount, remark, tenant_id)
 SELECT id, 99, '其他费用（历史迁移）', other_expenses_amount, '从旧数据迁移', tenant_id
 FROM financial_settlement
 WHERE other_expenses_amount > 0
   AND del_flag = '0'
   AND id NOT IN (SELECT DISTINCT pid FROM financial_settlement_expense WHERE del_flag = '0');

 兼容判断逻辑：
 // 查询时判断是否为旧数据
 public FinancialSettlementVo queryById(Long id) {
     FinancialSettlementVo vo = super.queryById(id);

     List<FinancialSettlementExpenseVo> expenses = expenseMapper.selectByPid(id);
     vo.setExpenseList(expenses);

     // 旧数据判断：有 otherExpensesAmount 但无费用明细
     if (CollUtil.isEmpty(expenses) && vo.getOtherExpensesAmount() != null
         && vo.getOtherExpensesAmount().compareTo(BigDecimal.ZERO) > 0) {
         vo.setLegacyData(true); // 标记为旧数据，前端显示提示
     }

     return vo;
 }

 0.6 参数配置取参逻辑

 配置优先级（从高到低）：
 1. 指定商户 + 当前生效 → 优先使用
 2. 全局配置（merchant_id IS NULL）+ 当前生效 → 次选
 3. 无匹配 → 抛出异常

 有效期规则：
 - effective_date <= 当前日期 <= expiry_date（expiry_date 为空表示永久有效）
 - 同一 config_code 不允许有效期重叠

 取参逻辑：
 public FinancialExpenseConfig getEffectiveConfig(String configCode, Long merchantId, LocalDate calcDate) {
     // 1. 优先查找指定商户的配置
     FinancialExpenseConfig config = configMapper.selectOne(Wrappers.<FinancialExpenseConfig>lambdaQuery()
         .eq(FinancialExpenseConfig::getConfigCode, configCode)
         .eq(FinancialExpenseConfig::getMerchantId, merchantId)
         .le(FinancialExpenseConfig::getEffectiveDate, calcDate)
         .and(w -> w.isNull(FinancialExpenseConfig::getExpiryDate)
             .or().ge(FinancialExpenseConfig::getExpiryDate, calcDate))
         .eq(FinancialExpenseConfig::getStatus, 1)
         .orderByDesc(FinancialExpenseConfig::getEffectiveDate)
         .last("LIMIT 1"));

     if (config != null) {
         return config;
     }

     // 2. 查找全局配置
     config = configMapper.selectOne(Wrappers.<FinancialExpenseConfig>lambdaQuery()
         .eq(FinancialExpenseConfig::getConfigCode, configCode)
         .isNull(FinancialExpenseConfig::getMerchantId)
         .le(FinancialExpenseConfig::getEffectiveDate, calcDate)
         .and(w -> w.isNull(FinancialExpenseConfig::getExpiryDate)
             .or().ge(FinancialExpenseConfig::getExpiryDate, calcDate))
         .eq(FinancialExpenseConfig::getStatus, 1)
         .orderByDesc(FinancialExpenseConfig::getEffectiveDate)
         .last("LIMIT 1"));

     if (config == null) {
         throw new ServiceException("未找到有效的费率配置：" + configCode);
     }

     return config;
 }

 calc_method 与公式对应：
 ┌───────────────┬───────────────────────────────────┐
 │  calc_method  │             计算逻辑              │
 ├───────────────┼───────────────────────────────────┤
 │ 1 (按天×费率) │ amount = base × rate / 360 × days │
 ├───────────────┼───────────────────────────────────┤
 │ 2 (阶梯步进)  │ 解析 tier_rules JSON，按阶梯计算  │
 ├───────────────┼───────────────────────────────────┤
 │ 3 (固定金额)  │ amount = rate_value（直接取值）   │
 └───────────────┴───────────────────────────────────┘
 base_type 与基数对应：
 ┌────────────────┬────────────────────────────────────────┐
 │   base_type    │                基数取值                │
 ├────────────────┼────────────────────────────────────────┤
 │ 1 (含税金额)   │ settlement.goodsAmount                 │
 ├────────────────┼────────────────────────────────────────┤
 │ 2 (不含税金额) │ settlement.goodsAmount / (1 + taxRate) │
 ├────────────────┼────────────────────────────────────────┤
 │ 3 (数量)       │ settlement.goodsQty                    │
 └────────────────┴────────────────────────────────────────┘
 0.7 费用表唯一键处理

 现有唯一键：
 CREATE UNIQUE INDEX uk_expense_source
     ON financial_settlement_expense(pid, expense_type, source_doc_id)
     WHERE del_flag = '0' AND source_doc_id IS NOT NULL;

 问题：无 source_doc_id 时可能重复

 解决方案：添加序号字段
 -- 新增序号字段
 ALTER TABLE financial_settlement_expense
 ADD COLUMN IF NOT EXISTS seq_no SMALLINT DEFAULT 1;

 -- 修改唯一键（覆盖无来源场景）
 CREATE UNIQUE INDEX IF NOT EXISTS uk_expense_type_seq
     ON financial_settlement_expense(pid, expense_type, seq_no)
     WHERE del_flag = '0';

 业务规则：
 - 同一结算单下，同一费用类型可有多条（seq_no 递增）
 - 有 source_doc_id 时，用原唯一键保证不重复
 - 无 source_doc_id 时，用 (pid, expense_type, seq_no) 保证唯一

 seq_no 生成逻辑（后端）：
 public void saveExpenseList(Long settlementId, List<FinancialSettlementExpenseBo> expenseList) {
     // 1. 删除原有费用明细
     expenseMapper.deleteByPid(settlementId);

     if (CollUtil.isEmpty(expenseList)) {
         return;
     }

     // 2. 按费用类型分组，生成 seq_no
     Map<Integer, AtomicInteger> seqMap = new HashMap<>();

     List<FinancialSettlementExpense> entities = expenseList.stream()
         .map(bo -> {
             FinancialSettlementExpense entity = MapstructUtils.convert(bo, FinancialSettlementExpense.class);
             entity.setPid(settlementId);

             // 生成 seq_no（同类型递增）
             int expenseType = entity.getExpenseType();
             AtomicInteger seq = seqMap.computeIfAbsent(expenseType, k -> new AtomicInteger(0));
             entity.setSeqNo(seq.incrementAndGet());

             return entity;
         })
         .collect(Collectors.toList());

     // 3. 批量插入
     expenseMapper.insertBatch(entities);

     // 4. 更新主表费用合计
     updateExpenseTotal(settlementId);
 }

 前端不需要传 seq_no，由后端自动生成

 ---
 一、费用口径定义（已部分确认）

 1.1 垫资利息口径（待冻结 - 见 0.1）

 1.2 通道费口径（已确认）
 ┌──────────┬─────────────┬───────────────────────┐
 │   参数   │   确定值    │         说明          │
 ├──────────┼─────────────┼───────────────────────┤
 │ 计费基数 │ 数量（吨）  │ 按吨数计费            │
 ├──────────┼─────────────┼───────────────────────┤
 │ 免费期   │ 30天        │ 前30天免通道费        │
 ├──────────┼─────────────┼───────────────────────┤
 │ 步进周期 │ 1天         │ 超过30天后，每1天累计 │
 ├──────────┼─────────────┼───────────────────────┤
 │ 单价     │ 0.5元/吨/天 │ 超期费率              │
 ├──────────┼─────────────┼───────────────────────┤
 │ 计费方式 │ 阶梯步进    │ 免费期 + 按天累计     │
 └──────────┴─────────────┴───────────────────────┘
 通道费计算公式：
 若 垫资天数 <= 30天：
     通道费 = 0

 若 垫资天数 > 30天：
     超期天数 = 垫资天数 - 30
     步进次数 = CEILING(超期天数 / N)  // N为步进周期（如2天）
     通道费 = 数量(吨) × 步进次数 × 单次费用(元/吨)

 已确认参数：
 - 免费期：30天
 - 步进周期：1天
 - 单次费用：0.5元/吨

 最终公式：
 若 垫资天数 <= 30天：
     通道费 = 0

 若 垫资天数 > 30天：
     超期天数 = 垫资天数 - 30
     通道费 = 数量(吨) × 超期天数 × 0.5(元/吨/天)

 验收算例：
 ┌──────┬──────────┬──────────┬──────────┬─────────────────┬──────────┐
 │ 序号 │ 垫资天数 │ 数量(吨) │ 超期天数 │   通道费计算    │   结果   │
 ├──────┼──────────┼──────────┼──────────┼─────────────────┼──────────┤
 │ 1    │ 25天     │ 500      │ 0        │ 免费期内        │ 0元      │
 ├──────┼──────────┼──────────┼──────────┼─────────────────┼──────────┤
 │ 2    │ 30天     │ 500      │ 0        │ 免费期内        │ 0元      │
 ├──────┼──────────┼──────────┼──────────┼─────────────────┼──────────┤
 │ 3    │ 35天     │ 500      │ 5        │ 500 × 5 × 0.5   │ 1,250元  │
 ├──────┼──────────┼──────────┼──────────┼─────────────────┼──────────┤
 │ 4    │ 45天     │ 500      │ 15       │ 500 × 15 × 0.5  │ 3,750元  │
 ├──────┼──────────┼──────────┼──────────┼─────────────────┼──────────┤
 │ 5    │ 60天     │ 1000     │ 30       │ 1000 × 30 × 0.5 │ 15,000元 │
 └──────┴──────────┴──────────┴──────────┴─────────────────┴──────────┘
 1.3 贴息口径（已确认）
 ┌──────────┬──────────────────┬─────────────────────┐
 │   参数   │      确认值      │        说明         │
 ├──────────┼──────────────────┼─────────────────────┤
 │ 计算方式 │ 银行汇票贴现     │ 按银行贴现惯例计算  │
 ├──────────┼──────────────────┼─────────────────────┤
 │ 贴息基数 │ 汇票金额（含税） │ 采购付款的含税金额  │
 ├──────────┼──────────────────┼─────────────────────┤
 │ 贴息率   │ 2.3%（年化）     │ 年化贴息率          │
 ├──────────┼──────────────────┼─────────────────────┤
 │ 天数基准 │ 360天/年         │ 银行贴现惯例        │
 ├──────────┼──────────────────┼─────────────────────┤
 │ 贴现期限 │ 按实际天数       │ 垫资天数（如120天） │
 └──────────┴──────────────────┴─────────────────────┘
 贴息计算公式：
 贴息 = 汇票金额 × 贴息率 × 贴现天数 / 360

 其中：
 - 汇票金额 = 采购付款含税金额
 - 贴息率 = 2.3%（年化，即0.023）
 - 贴现天数 = 垫资天数（付款日到回款日）

 验收算例：
 ┌──────┬──────────┬────────┬───────┬───────────────────────────────┬─────────────┐
 │ 序号 │ 汇票金额 │ 贴息率 │ 天数  │           贴息计算            │    结果     │
 ├──────┼──────────┼────────┼───────┼───────────────────────────────┼─────────────┤
 │ 1    │ 100万    │ 2.3%   │ 120天 │ 1,000,000 × 0.023 × 120 / 360 │ 7,666.67元  │
 ├──────┼──────────┼────────┼───────┼───────────────────────────────┼─────────────┤
 │ 2    │ 100万    │ 2.3%   │ 90天  │ 1,000,000 × 0.023 × 90 / 360  │ 5,750.00元  │
 ├──────┼──────────┼────────┼───────┼───────────────────────────────┼─────────────┤
 │ 3    │ 50万     │ 2.3%   │ 60天  │ 500,000 × 0.023 × 60 / 360    │ 1,916.67元  │
 ├──────┼──────────┼────────┼───────┼───────────────────────────────┼─────────────┤
 │ 4    │ 200万    │ 2.3%   │ 180天 │ 2,000,000 × 0.023 × 180 / 360 │ 23,000.00元 │
 └──────┴──────────┴────────┴───────┴───────────────────────────────┴─────────────┘
 适用场景：
 - 银行垫资模式下，展形需承担的银行贴息费用
 - 贴息率可在参数表中配置，支持按商户/时间段调整

 1.4 物流费用口径
 ┌──────────┬──────────┬────────┬──────────┐
 │ 费用类型 │ 计算公式 │  基数  │   单位   │
 ├──────────┼──────────┼────────┼──────────┤
 │ 船运费   │ 待确认   │ 待确认 │ 元/吨    │
 ├──────────┼──────────┼────────┼──────────┤
 │ 港口费   │ 待确认   │ 待确认 │ 元/吨    │
 ├──────────┼──────────┼────────┼──────────┤
 │ 仓储费   │ 待确认   │ 待确认 │ 元/吨/天 │
 ├──────────┼──────────┼────────┼──────────┤
 │ 加工费   │ 待确认   │ 待确认 │ 元/吨    │
 ├──────────┼──────────┼────────┼──────────┤
 │ 装卸费   │ 待确认   │ 待确认 │ 元/吨    │
 └──────────┴──────────┴────────┴──────────┘
 ---
 二、现有架构对齐

 2.1 实体继承链（已确认）

 FinancialSettlement
   └── BaseFinancialSettlement (6字段: deliveryDate, operatorId, weightSlipType, sourceType, period)
         └── BaseBill (5字段: otherExpensesAmount, discountAmount, actualAmount, merchantId, prepayAmount)
               └── BaseDoc (7字段: id, docNo, docDate, goodsQty, goodsAmount, checkedStatus, warehouseId, remark)
                     └── BaseEntity (6字段: createDept, createBy, createTime, updateBy, updateTime, params)

 2.2 现有字段复用
 ┌─────────────────────┬──────────┬──────────────────────────────────────────────────┐
 │      现有字段       │   位置   │                     复用方式                     │
 ├─────────────────────┼──────────┼──────────────────────────────────────────────────┤
 │ otherExpensesAmount │ BaseBill │ 可用于存储费用合计，但建议新增明细表存储各项费用 │
 ├─────────────────────┼──────────┼──────────────────────────────────────────────────┤
 │ discountAmount      │ BaseBill │ 保持原用途（优惠金额）                           │
 ├─────────────────────┼──────────┼──────────────────────────────────────────────────┤
 │ actualAmount        │ BaseBill │ 保持原计算逻辑                                   │
 ├─────────────────────┼──────────┼──────────────────────────────────────────────────┤
 │ prepayAmount        │ BaseBill │ 可用于垫资金额（或新增 advanceAmount）           │
 └─────────────────────┴──────────┴──────────────────────────────────────────────────┘
 2.3 需要扩展的字段

 在 FinancialSettlement 实体中新增以下字段：
 ┌────────────────────┬────────────┬──────────────────────────────────────┬───────────────────┐
 │       字段名       │    类型    │                 说明                 │       位置        │
 ├────────────────────┼────────────┼──────────────────────────────────────┼───────────────────┤
 │ advanceType        │ Integer    │ 垫资类型：0=无 1=自有资金 2=银行垫资 │ Entity            │
 ├────────────────────┼────────────┼──────────────────────────────────────┼───────────────────┤
 │ advanceAmount      │ BigDecimal │ 垫资金额                             │ Entity            │
 ├────────────────────┼────────────┼──────────────────────────────────────┼───────────────────┤
 │ advanceStartDate   │ LocalDate  │ 计息开始日                           │ Entity            │
 ├────────────────────┼────────────┼──────────────────────────────────────┼───────────────────┤
 │ advanceEndDate     │ LocalDate  │ 计息结束日                           │ Entity            │
 ├────────────────────┼────────────┼──────────────────────────────────────┼───────────────────┤
 │ advanceDays        │ Integer    │ 垫资天数                             │ Entity            │
 ├────────────────────┼────────────┼──────────────────────────────────────┼───────────────────┤
 │ interestRate       │ BigDecimal │ 日利率快照（保存计算时的利率）       │ Entity            │
 ├────────────────────┼────────────┼──────────────────────────────────────┼───────────────────┤
 │ interestAmount     │ BigDecimal │ 利息金额                             │ Entity            │
 ├────────────────────┼────────────┼──────────────────────────────────────┼───────────────────┤
 │ channelFeeRate     │ BigDecimal │ 通道费率快照                         │ Entity            │
 ├────────────────────┼────────────┼──────────────────────────────────────┼───────────────────┤
 │ channelFeeAmount   │ BigDecimal │ 通道费金额                           │ Entity            │
 ├────────────────────┼────────────┼──────────────────────────────────────┼───────────────────┤
 │ subsidyRate        │ BigDecimal │ 贴息比例快照                         │ Entity            │
 ├────────────────────┼────────────┼──────────────────────────────────────┼───────────────────┤
 │ subsidyAmount      │ BigDecimal │ 贴息金额                             │ Entity            │
 ├────────────────────┼────────────┼──────────────────────────────────────┼───────────────────┤
 │ formulaSnapshot    │ String     │ 完整公式快照（JSON）                 │ Entity            │
 ├────────────────────┼────────────┼──────────────────────────────────────┼───────────────────┤
 │ totalExpenseAmount │ BigDecimal │ 费用明细合计                         │ Entity/VO计算字段 │
 └────────────────────┴────────────┴──────────────────────────────────────┴───────────────────┘
 2.4 BO/VO/Mapper 扩展位置
 ┌─────────┬─────────────────────────────────┬───────────────────────────┐
 │   层    │              文件               │         扩展方式          │
 ├─────────┼─────────────────────────────────┼───────────────────────────┤
 │ Entity  │ FinancialSettlement.java        │ 直接添加字段              │
 ├─────────┼─────────────────────────────────┼───────────────────────────┤
 │ Bo      │ FinancialSettlementBo.java      │ 添加字段 + @ExcelProperty │
 ├─────────┼─────────────────────────────────┼───────────────────────────┤
 │ Vo      │ FinancialSettlementVo.java      │ 添加字段 + Excel注解      │
 ├─────────┼─────────────────────────────────┼───────────────────────────┤
 │ Mapper  │ FinancialSettlementMapper.xml   │ 自动继承，无需修改        │
 ├─────────┼─────────────────────────────────┼───────────────────────────┤
 │ Service │ FinancialSettlementService.java │ 添加计算方法              │
 └─────────┴─────────────────────────────────┴───────────────────────────┘
 2.5 MapStruct 转换（自动）

 由于使用 @AutoMapper 注解，字段扩展后 MapStruct 会自动处理转换：

 // Entity -> Bo
 FinancialSettlementBo bo = MapstructUtils.convert(entity, FinancialSettlementBo.class);

 // Bo -> Entity (保存时)
 FinancialSettlement entity = MapstructUtils.convert(bo, FinancialSettlement.class);

 ---
 三、数据库扩展

 3.1 扩展 financial_settlement 表

 -- ==========================================
 -- 垫资相关字段扩展
 -- ==========================================

 -- 垫资类型：0=无垫资 1=自有资金 2=银行垫资
 ALTER TABLE financial_settlement
 ADD COLUMN IF NOT EXISTS advance_type SMALLINT DEFAULT 0;

 -- 垫资金额
 ALTER TABLE financial_settlement
 ADD COLUMN IF NOT EXISTS advance_amount NUMERIC(18,2) DEFAULT 0;

 -- 计息开始日
 ALTER TABLE financial_settlement
 ADD COLUMN IF NOT EXISTS advance_start_date DATE;

 -- 计息结束日
 ALTER TABLE financial_settlement
 ADD COLUMN IF NOT EXISTS advance_end_date DATE;

 -- 垫资天数
 ALTER TABLE financial_settlement
 ADD COLUMN IF NOT EXISTS advance_days INTEGER DEFAULT 0;

 -- 日利率快照（精度到小数点后6位，如 0.000500 = 0.05%）
 ALTER TABLE financial_settlement
 ADD COLUMN IF NOT EXISTS interest_rate NUMERIC(10,6) DEFAULT 0;

 -- 利息金额
 ALTER TABLE financial_settlement
 ADD COLUMN IF NOT EXISTS interest_amount NUMERIC(18,2) DEFAULT 0;

 -- 通道费率快照
 ALTER TABLE financial_settlement
 ADD COLUMN IF NOT EXISTS channel_fee_rate NUMERIC(10,6) DEFAULT 0;

 -- 通道费金额
 ALTER TABLE financial_settlement
 ADD COLUMN IF NOT EXISTS channel_fee_amount NUMERIC(18,2) DEFAULT 0;

 -- 贴息比例快照（精度到小数点后4位，如 0.3000 = 30%）
 ALTER TABLE financial_settlement
 ADD COLUMN IF NOT EXISTS subsidy_rate NUMERIC(6,4) DEFAULT 0;

 -- 贴息金额
 ALTER TABLE financial_settlement
 ADD COLUMN IF NOT EXISTS subsidy_amount NUMERIC(18,2) DEFAULT 0;

 -- 公式快照（JSON格式，存储计算时的完整参数）
 ALTER TABLE financial_settlement
 ADD COLUMN IF NOT EXISTS formula_snapshot TEXT;

 -- 费用明细合计
 ALTER TABLE financial_settlement
 ADD COLUMN IF NOT EXISTS total_expense_amount NUMERIC(18,2) DEFAULT 0;

 -- 索引
 CREATE INDEX IF NOT EXISTS idx_settlement_advance_type
     ON financial_settlement(advance_type)
     WHERE del_flag = '0';

 3.2 新建费用明细表

 -- ==========================================
 -- 费用明细表（与商品明细 financial_settlement_detail 并行）
 -- ==========================================

 CREATE TABLE IF NOT EXISTS financial_settlement_expense (
     -- 主键
     id              BIGSERIAL PRIMARY KEY,

     -- 关联结算单（外键）
     pid             BIGINT NOT NULL,

     -- 费用信息
     expense_type    SMALLINT NOT NULL,             -- 费用类型（字典 erp_expense_type）
     expense_name    VARCHAR(100),                  -- 费用名称（冗余，便于展示）
     seq_no          SMALLINT DEFAULT 1 NOT NULL,   -- 序号（同类型递增，后端自动生成）
     qty             NUMERIC(18,3) DEFAULT 0,       -- 数量（吨）
     unit_price      NUMERIC(18,6) DEFAULT 0,       -- 单价（精度6位）
     days            INTEGER DEFAULT 0,             -- 天数（仓储费用）
     amount          NUMERIC(18,2) DEFAULT 0,       -- 金额（自动计算）
     tax_rate        NUMERIC(5,2) DEFAULT 0,        -- 税率（%）
     tax_amount      NUMERIC(18,2) DEFAULT 0,       -- 税额
     amount_without_tax NUMERIC(18,2) DEFAULT 0,    -- 不含税金额

     -- 来源关联
     source_doc_type VARCHAR(50),                   -- 来源单据类型
     source_doc_no   VARCHAR(50),                   -- 来源单据号
     source_doc_id   BIGINT,                        -- 来源单据ID

     -- 公式快照（JSON格式，最大10000字符）
     formula_snapshot TEXT,

     -- 备注
     remark          VARCHAR(500),

     -- ==========================================
     -- 标准字段（继承 TenantEntity 规范）
     -- ==========================================
     create_dept     BIGINT,
     create_by       BIGINT,
     create_time     TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
     update_by       BIGINT,
     update_time     TIMESTAMP,
     tenant_id       VARCHAR(20) DEFAULT '000000' NOT NULL,
     del_flag        CHAR(1) DEFAULT '0' NOT NULL,

     -- 外键约束
     CONSTRAINT fk_expense_settlement_pid
         FOREIGN KEY (pid) REFERENCES financial_settlement(id) ON DELETE CASCADE
 );

 -- 索引
 CREATE INDEX IF NOT EXISTS idx_expense_pid
     ON financial_settlement_expense(pid)
     WHERE del_flag = '0';

 CREATE INDEX IF NOT EXISTS idx_expense_tenant
     ON financial_settlement_expense(tenant_id)
     WHERE del_flag = '0';

 CREATE INDEX IF NOT EXISTS idx_expense_type
     ON financial_settlement_expense(expense_type)
     WHERE del_flag = '0';

 -- 唯一约束1：同一结算单下，同一费用类型+序号唯一（覆盖无来源场景）
 CREATE UNIQUE INDEX IF NOT EXISTS uk_expense_type_seq
     ON financial_settlement_expense(pid, expense_type, seq_no)
     WHERE del_flag = '0';

 -- 唯一约束2：同一结算单下，同一费用类型+来源单据唯一（有来源时）
 CREATE UNIQUE INDEX IF NOT EXISTS uk_expense_source
     ON financial_settlement_expense(pid, expense_type, source_doc_id)
     WHERE del_flag = '0' AND source_doc_id IS NOT NULL;

 -- 注释
 COMMENT ON TABLE financial_settlement_expense IS '结算单费用明细表';
 COMMENT ON COLUMN financial_settlement_expense.expense_type IS '费用类型：1=船运费 2=港口费 3=仓储费 4=加工费
 5=装卸费 99=其他';
 COMMENT ON COLUMN financial_settlement_expense.formula_snapshot IS
 'JSON格式：{"rate":0.05,"days":30,"base":1000000,"qty":500,"operator":"admin","time":"2024-01-15"}';

 3.3 新建费用配置表

 -- ==========================================
 -- 费用参数配置表
 -- ==========================================

 CREATE TABLE IF NOT EXISTS financial_expense_config (
     -- 主键
     id              BIGSERIAL PRIMARY KEY,

     -- 配置标识
     config_code     VARCHAR(50) NOT NULL,          -- 配置编码（如 INTEREST_RATE_SELF, CHANNEL_FEE）
     config_name     VARCHAR(100),                  -- 配置名称
     config_type     SMALLINT NOT NULL,             -- 类型：1=垫资利率 2=通道费率 3=贴息比例 4=物流费率

     -- 费率参数
     rate_value      NUMERIC(12,6) DEFAULT 0,       -- 费率值
     rate_unit       VARCHAR(20) DEFAULT 'day',     -- 单位：day=日 month=月 year=年
     base_type       SMALLINT DEFAULT 1,            -- 基数类型：1=含税金额 2=不含税金额 3=数量
     calc_method     SMALLINT DEFAULT 1,            -- 计算方式：1=按天×费率 2=阶梯步进 3=固定金额

     -- 阶梯规则（JSON数组）
     tier_rules      TEXT,                          --
 [{"minDays":0,"maxDays":30,"rate":0.0005},{"minDays":31,"maxDays":60,"rate":0.0006}]

     -- 适用范围
     merchant_id     BIGINT,                        -- 适用商户（NULL=全部）
     expense_type    SMALLINT,                      -- 适用费用类型（NULL=全部）
     effective_date  DATE NOT NULL,                 -- 生效日期
     expiry_date     DATE,                          -- 失效日期（NULL=永久）

     -- 状态
     status          SMALLINT DEFAULT 1,            -- 状态：0=禁用 1=启用

     -- 标准字段
     create_dept     BIGINT,
     create_by       BIGINT,
     create_time     TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
     update_by       BIGINT,
     update_time     TIMESTAMP,
     tenant_id       VARCHAR(20) DEFAULT '000000' NOT NULL,
     del_flag        CHAR(1) DEFAULT '0' NOT NULL
 );

 -- 唯一索引（同一租户、编码、生效日期唯一）
 CREATE UNIQUE INDEX IF NOT EXISTS uk_expense_config
     ON financial_expense_config(tenant_id, config_code, effective_date)
     WHERE del_flag = '0';

 -- 索引
 CREATE INDEX IF NOT EXISTS idx_config_type
     ON financial_expense_config(config_type)
     WHERE del_flag = '0';

 CREATE INDEX IF NOT EXISTS idx_config_effective
     ON financial_expense_config(effective_date, expiry_date)
     WHERE del_flag = '0' AND status = 1;

 -- 注释
 COMMENT ON TABLE financial_expense_config IS '费用参数配置表';
 COMMENT ON COLUMN financial_expense_config.tier_rules IS
 'JSON阶梯规则：[{"minDays":起始天,"maxDays":结束天,"rate":费率}]';

 3.4 字典数据初始化

 -- ==========================================
 -- 字典类型
 -- ==========================================

 -- 垫资类型
 INSERT INTO sys_dict_type (dict_name, dict_type, status, create_time, remark, tenant_id)
 VALUES ('垫资类型', 'erp_advance_type', '0', NOW(), '展形ERP垫资类型', '000000')
 ON CONFLICT DO NOTHING;

 -- 费用类型
 INSERT INTO sys_dict_type (dict_name, dict_type, status, create_time, remark, tenant_id)
 VALUES ('费用类型', 'erp_expense_type', '0', NOW(), '展形ERP费用类型', '000000')
 ON CONFLICT DO NOTHING;

 -- 费率基数类型
 INSERT INTO sys_dict_type (dict_name, dict_type, status, create_time, remark, tenant_id)
 VALUES ('费率基数类型', 'erp_base_type', '0', NOW(), '费用计算基数类型', '000000')
 ON CONFLICT DO NOTHING;

 -- ==========================================
 -- 字典数据
 -- ==========================================

 -- erp_advance_type
 INSERT INTO sys_dict_data (dict_sort, dict_label, dict_value, dict_type, status, create_time, tenant_id)
 VALUES
     (1, '无垫资', '0', 'erp_advance_type', '0', NOW(), '000000'),
     (2, '自有资金', '1', 'erp_advance_type', '0', NOW(), '000000'),
     (3, '银行垫资', '2', 'erp_advance_type', '0', NOW(), '000000')
 ON CONFLICT DO NOTHING;

 -- erp_expense_type
 INSERT INTO sys_dict_data (dict_sort, dict_label, dict_value, dict_type, status, create_time, tenant_id)
 VALUES
     (1, '船运费', '1', 'erp_expense_type', '0', NOW(), '000000'),
     (2, '港口费', '2', 'erp_expense_type', '0', NOW(), '000000'),
     (3, '仓储费', '3', 'erp_expense_type', '0', NOW(), '000000'),
     (4, '加工费', '4', 'erp_expense_type', '0', NOW(), '000000'),
     (5, '装卸费', '5', 'erp_expense_type', '0', NOW(), '000000'),
     (99, '其他费用', '99', 'erp_expense_type', '0', NOW(), '000000')
 ON CONFLICT DO NOTHING;

 -- erp_base_type
 INSERT INTO sys_dict_data (dict_sort, dict_label, dict_value, dict_type, status, create_time, tenant_id)
 VALUES
     (1, '含税金额', '1', 'erp_base_type', '0', NOW(), '000000'),
     (2, '不含税金额', '2', 'erp_base_type', '0', NOW(), '000000'),
     (3, '数量(吨)', '3', 'erp_base_type', '0', NOW(), '000000')
 ON CONFLICT DO NOTHING;

 ---
 四、公式快照 JSON Schema

 4.0 存储约束
 ┌──────────┬───────────────────┬────────────────────────────┐
 │  约束项  │       规格        │            说明            │
 ├──────────┼───────────────────┼────────────────────────────┤
 │ 字段类型 │ TEXT (PostgreSQL) │ 不使用 JSON 类型，便于迁移 │
 ├──────────┼───────────────────┼────────────────────────────┤
 │ 最大长度 │ 10,000 字符       │ 后端校验，超长截断或拒绝   │
 ├──────────┼───────────────────┼────────────────────────────┤
 │ 编码     │ UTF-8             │ 标准 JSON 格式             │
 ├──────────┼───────────────────┼────────────────────────────┤
 │ 压缩     │ 无                │ 保持可读性，便于排查       │
 └──────────┴───────────────────┴────────────────────────────┘
 后端校验：
 public void validateFormulaSnapshot(String snapshot) {
     if (StringUtils.isBlank(snapshot)) {
         return; // 允许为空（草稿状态）
     }
     if (snapshot.length() > 10000) {
         throw new ServiceException("公式快照超过10000字符限制");
     }
     // JSON格式校验
     try {
         JsonUtils.parseObject(snapshot, FormulaSnapshot.class);
     } catch (Exception e) {
         throw new ServiceException("公式快照格式错误");
     }
 }

 4.1 结算单级别公式快照（formula_snapshot）

 Schema 版本: v1.0（后续升级需兼容旧版本）

 {
   "version": "1.0",
   "calculatedAt": "2024-01-15T10:30:00",
   "calculatedBy": "admin",
   "calculatedByName": "管理员",

   "advance": {
     "type": 1,
     "typeName": "自有资金",
     "principal": 1000000.00,
     "principalBase": "含税金额",
     "startDate": "2024-01-01",
     "endDate": "2024-01-31",
     "days": 30,
     "daysCalcMethod": "nature",
     "inclusive": false,
     "rateAnnual": 0.18,
     "rateDaily": 0.000493,
     "rateSource": "INTEREST_RATE_SELF",
     "interest": 14794.52,
     "formula": "1000000.00 × 0.000493 × 30 = 14794.52"
   },

   "channelFee": {
     "enabled": true,
     "principal": 1000000.00,
     "rate": 0.0001,
     "days": 30,
     "amount": 3000.00,
     "formula": "1000000.00 × 0.0001 × 30 = 3000.00"
   },

   "subsidy": {
     "enabled": false,
     "rate": 0,
     "amount": 0
   },

   "expenses": {
     "shipping": 25000.00,
     "port": 5000.00,
     "storage": 3000.00,
     "processing": 10000.00,
     "handling": 2000.00,
     "other": 0,
     "total": 45000.00
   },

   "summary": {
     "salesAmount": 1200000.00,
     "purchaseAmount": 1000000.00,
     "grossProfit": 200000.00,
     "expenseTotal": 45000.00,
     "interestTotal": 14794.52,
     "channelFeeTotal": 3000.00,
     "netProfit": 137205.48,
     "profitRate": 0.1143
   }
 }

 4.2 费用明细级别公式快照

 {
   "version": "1.0",
   "calculatedAt": "2024-01-15T10:30:00",
   "expenseType": 1,
   "expenseTypeName": "船运费",
   "qty": 500.000,
   "qtyUnit": "吨",
   "unitPrice": 50.00,
   "priceUnit": "元/吨",
   "days": null,
   "taxRate": 9.00,
   "formula": "500.000 吨 × 50.00 元/吨 = 25000.00 元",
   "amount": 25000.00,
   "taxAmount": 2252.25,
   "amountWithoutTax": 22747.75
 }

 ---
 五、后端扩展实现

 5.1 Entity 扩展

 文件: FinancialSettlement.java

 @Data
 @EqualsAndHashCode(callSuper = true)
 @TableName("financial_settlement")
 public class FinancialSettlement extends BaseFinancialSettlement {

     // ==========================================
     // 垫资相关字段（新增）
     // ==========================================

     /** 垫资类型：0=无垫资 1=自有资金 2=银行垫资 */
     private Integer advanceType;

     /** 垫资金额 */
     private BigDecimal advanceAmount;

     /** 计息开始日 */
     @JsonFormat(pattern = "yyyy-MM-dd")
     private LocalDate advanceStartDate;

     /** 计息结束日 */
     @JsonFormat(pattern = "yyyy-MM-dd")
     private LocalDate advanceEndDate;

     /** 垫资天数 */
     private Integer advanceDays;

     /** 日利率快照 */
     private BigDecimal interestRate;

     /** 利息金额 */
     private BigDecimal interestAmount;

     /** 通道费率快照 */
     private BigDecimal channelFeeRate;

     /** 通道费金额 */
     private BigDecimal channelFeeAmount;

     /** 贴息比例快照 */
     private BigDecimal subsidyRate;

     /** 贴息金额 */
     private BigDecimal subsidyAmount;

     /** 费用明细合计 */
     private BigDecimal totalExpenseAmount;

     /** 公式快照（JSON） */
     private String formulaSnapshot;
 }

 5.2 BO 扩展

 文件: FinancialSettlementBo.java

 @Data
 @EqualsAndHashCode(callSuper = true)
 @AutoMapper(target = FinancialSettlement.class)
 public class FinancialSettlementBo extends BaseFinancialSettlementBo<FinancialSettlementDetailBo> {

     @ExcelProperty(value = "行号")
     private String crown;

     // ==========================================
     // 垫资相关字段
     // ==========================================

     @ExcelProperty(value = "垫资类型", converter = ExcelDictConvert.class)
     @ExcelDictFormat(dictType = "erp_advance_type")
     private Integer advanceType;

     @ExcelProperty(value = "垫资金额")
     private BigDecimal advanceAmount;

     @ExcelProperty(value = "计息开始日")
     private LocalDate advanceStartDate;

     @ExcelProperty(value = "计息结束日")
     private LocalDate advanceEndDate;

     @ExcelProperty(value = "垫资天数")
     private Integer advanceDays;

     @ExcelProperty(value = "日利率")
     private BigDecimal interestRate;

     @ExcelProperty(value = "利息金额")
     private BigDecimal interestAmount;

     private BigDecimal channelFeeRate;
     private BigDecimal channelFeeAmount;
     private BigDecimal subsidyRate;
     private BigDecimal subsidyAmount;
     private BigDecimal totalExpenseAmount;
     private String formulaSnapshot;

     // ==========================================
     // 费用明细列表
     // ==========================================

     /** 费用明细列表 */
     @TableField(exist = false)
     private List<FinancialSettlementExpenseBo> expenseList;
 }

 5.3 费用计算引擎

 文件: ExpenseCalculationEngine.java

 @Service
 @RequiredArgsConstructor
 public class ExpenseCalculationEngine {

     private final FinancialExpenseConfigMapper expenseConfigMapper;

     /**
      * 计算垫资利息
      *
      * @param principal    本金
      * @param startDate    开始日期
      * @param endDate      结束日期
      * @param advanceType  垫资类型
      * @return 计算结果
      */
     public AdvanceInterestResult calculateInterest(
             BigDecimal principal,
             LocalDate startDate,
             LocalDate endDate,
             Integer advanceType
     ) {
         // 1. 查询利率配置
         String configCode = advanceType == 1 ? "INTEREST_RATE_SELF" : "INTEREST_RATE_BANK";
         FinancialExpenseConfig config = getEffectiveConfig(configCode, startDate);

         if (config == null) {
             throw new ServiceException("未找到有效的利率配置：" + configCode);
         }

         // 2. 计算天数
         long days = ChronoUnit.DAYS.between(startDate, endDate);
         if (days <= 0) {
             return new AdvanceInterestResult(BigDecimal.ZERO, 0, BigDecimal.ZERO, "天数为0，无需计算");
         }

         // 3. 获取日利率
         BigDecimal dailyRate = getDailyRate(config);

         // 4. 应用阶梯规则（如有）
         BigDecimal interest;
         String formula;
         if (StringUtils.isNotBlank(config.getTierRules())) {
             // 阶梯计算
             TierCalculationResult tierResult = calculateWithTiers(principal, days, config.getTierRules());
             interest = tierResult.getInterest();
             formula = tierResult.getFormula();
         } else {
             // 简单计算
             interest = principal.multiply(dailyRate).multiply(BigDecimal.valueOf(days));
             formula = String.format("%s × %s × %d = %s",
                 formatAmount(principal), formatRate(dailyRate), days, formatAmount(interest));
         }

         // 5. 构建公式快照
         String snapshot = buildInterestSnapshot(principal, dailyRate, days, interest, config);

         return new AdvanceInterestResult(interest, (int) days, dailyRate, snapshot);
     }

     /**
      * 计算物流费用
      */
     public ExpenseResult calculateExpense(
             Integer expenseType,
             BigDecimal qty,
             Integer days,
             BigDecimal unitPrice
     ) {
         BigDecimal amount;
         String formula;

         if (days != null && days > 0) {
             // 仓储费：单价 × 数量 × 天数
             amount = unitPrice.multiply(qty).multiply(BigDecimal.valueOf(days));
             formula = String.format("%s元/吨/天 × %s吨 × %d天 = %s元",
                 formatAmount(unitPrice), formatQty(qty), days, formatAmount(amount));
         } else {
             // 其他费用：单价 × 数量
             amount = unitPrice.multiply(qty);
             formula = String.format("%s元/吨 × %s吨 = %s元",
                 formatAmount(unitPrice), formatQty(qty), formatAmount(amount));
         }

         String snapshot = buildExpenseSnapshot(expenseType, qty, unitPrice, days, amount, formula);
         return new ExpenseResult(amount, snapshot);
     }

     // ... 其他辅助方法
 }

 5.4 Service 扩展

 文件: FinancialSettlementService.java 新增方法

 /**
  * 计算垫资利息（前端点击"计算"按钮调用）
  */
 public FinancialSettlementVo calculateAdvanceInterest(FinancialSettlementBo bo) {
     // 参数校验
     if (bo.getAdvanceType() == null || bo.getAdvanceType() == 0) {
         throw new ServiceException("垫资类型不能为空");
     }
     if (bo.getAdvanceAmount() == null || bo.getAdvanceAmount().compareTo(BigDecimal.ZERO) <= 0) {
         throw new ServiceException("垫资金额必须大于0");
     }
     if (bo.getAdvanceStartDate() == null || bo.getAdvanceEndDate() == null) {
         throw new ServiceException("计息日期不能为空");
     }
     if (bo.getAdvanceStartDate().isAfter(bo.getAdvanceEndDate())) {
         throw new ServiceException("计息开始日不能晚于结束日");
     }

     // 调用计算引擎
     AdvanceInterestResult result = expenseCalculationEngine.calculateInterest(
         bo.getAdvanceAmount(),
         bo.getAdvanceStartDate(),
         bo.getAdvanceEndDate(),
         bo.getAdvanceType()
     );

     // 回填结果
     bo.setAdvanceDays(result.getDays());
     bo.setInterestRate(result.getDailyRate());
     bo.setInterestAmount(result.getInterest());
     bo.setFormulaSnapshot(result.getSnapshot());

     return MapstructUtils.convert(bo, FinancialSettlementVo.class);
 }

 /**
  * 保存费用明细
  */
 @Transactional
 public void saveExpenseList(Long settlementId, List<FinancialSettlementExpenseBo> expenseList) {
     // 1. 删除原有费用明细
     expenseMapper.delete(Wrappers.<FinancialSettlementExpense>lambdaQuery()
         .eq(FinancialSettlementExpense::getPid, settlementId));

     // 2. 批量插入新费用
     if (CollUtil.isNotEmpty(expenseList)) {
         List<FinancialSettlementExpense> entities = expenseList.stream()
             .map(bo -> {
                 FinancialSettlementExpense entity = MapstructUtils.convert(bo, FinancialSettlementExpense.class);
                 entity.setPid(settlementId);
                 return entity;
             })
             .collect(Collectors.toList());

         expenseMapper.insertBatch(entities);

         // 3. 更新结算单的费用合计
         BigDecimal totalExpense = expenseList.stream()
             .map(FinancialSettlementExpenseBo::getAmount)
             .filter(Objects::nonNull)
             .reduce(BigDecimal.ZERO, BigDecimal::add);

         financialSettlementMapper.update(null, Wrappers.<FinancialSettlement>lambdaUpdate()
             .eq(FinancialSettlement::getId, settlementId)
             .set(FinancialSettlement::getTotalExpenseAmount, totalExpense));
     }
 }

 5.5 Controller 扩展

 /**
  * 计算垫资利息
  */
 @PostMapping("/calculateInterest")
 @SaCheckPermission("financial:settlement:edit")
 @Log(title = "结算单-计算利息", businessType = BusinessType.UPDATE)
 public R<FinancialSettlementVo> calculateInterest(@Validated @RequestBody FinancialSettlementBo bo) {
     return R.ok(financialSettlementService.calculateAdvanceInterest(bo));
 }

 /**
  * 保存费用明细
  */
 @PostMapping("/{id}/expense")
 @SaCheckPermission("financial:settlement:edit")
 @Log(title = "结算单-保存费用", businessType = BusinessType.UPDATE)
 public R<Void> saveExpense(
         @PathVariable Long id,
         @RequestBody List<FinancialSettlementExpenseBo> expenseList
 ) {
     financialSettlementService.saveExpenseList(id, expenseList);
     return R.ok();
 }

 /**
  * 查询费用明细
  */
 @GetMapping("/{id}/expense")
 @SaCheckPermission("financial:settlement:query")
 public R<List<FinancialSettlementExpenseVo>> getExpenseList(@PathVariable Long id) {
     return R.ok(financialSettlementService.queryExpenseList(id));
 }

 ---
 六、审批流集成

 6.1 流程代码

 保持现有命名规范：financial_settlement

 6.2 流程变量扩展

 在流程提交时，将垫资相关字段作为流程变量：

 @EventListener(condition = "#processEvent.flowCode.startsWith('financial_settlement')")
 public void processHandler(ProcessEvent processEvent) {
     FinancialSettlement settlement = financialSettlementMapper.selectById(
         Long.valueOf(processEvent.getBusinessId())
     );

     // 提交时锁定公式快照
     if (processEvent.getSubmit()) {
         // 确保公式快照已生成
         if (StringUtils.isBlank(settlement.getFormulaSnapshot())) {
             throw new ServiceException("请先计算利息和费用后再提交审批");
         }
         settlement.setCheckedStatus(BusinessStatusEnum.WAITING.getCode());
     }

     // 审批完成后的处理
     if (BusinessStatusEnum.FINISH.getStatus().equals(processEvent.getStatus())) {
         settlement.setCheckedStatus(BusinessStatusEnum.FINISH.getCode());
         // 触发后续业务（如更新商户余额等）
         afterApproveFunc(settlement);
     }

     financialSettlementMapper.updateById(settlement);
 }

 6.3 状态流转

 草稿(0) --提交--> 待审批(1) --审批通过--> 已完成(2)
                       |
                       +--驳回--> 草稿(0)
                       |
                       +--撤销--> 草稿(0)

 ---
 七、实施落地顺序

 Phase 0: 口径冻结（前置条件 - 阻塞后续）

 ⚠️ 不冻结口径，不开始开发

 ┌────────────────────────┬────────┬─────────────────────┐
 │        待冻结项        │ 负责人 │        状态         │
 ├────────────────────────┼────────┼─────────────────────┤
 │ 垫资利息口径（见 0.1） │ 用户   │ 待确认              │
 ├────────────────────────┼────────┼─────────────────────┤
 │ 物流费用口径（见 0.2） │ 用户   │ 待确认              │
 ├────────────────────────┼────────┼─────────────────────┤
 │ 与现有表关系（见 0.3） │ 用户   │ 待确认（推荐方案B） │
 └────────────────────────┴────────┴─────────────────────┘
 交付物：
 - 口径确认表（含所有参数取值）
 - 验收算例 3-5 个（用于自动化测试）

 ---
 Phase 1: 数据库迁移

 任务清单：

 1. 扩展主表 financial_settlement
 -- 执行 V1.0.0__extend_settlement.sql
 ALTER TABLE financial_settlement ADD COLUMN advance_type SMALLINT DEFAULT 0;
 ALTER TABLE financial_settlement ADD COLUMN advance_amount NUMERIC(18,2);
 -- ... 其他字段
 2. 新建费用明细表 financial_settlement_expense
 -- 执行 V1.0.1__create_expense_table.sql
 CREATE TABLE financial_settlement_expense (...);
 3. 新建费用配置表 financial_expense_config
 -- 执行 V1.0.2__create_config_table.sql
 CREATE TABLE financial_expense_config (...);
 4. 初始化字典数据
 -- 执行 V1.0.3__init_dict.sql
 INSERT INTO sys_dict_type ... (erp_advance_type, erp_expense_type, erp_base_type)
 5. 初始化默认费率配置
 -- 自有资金垫资利率：18%年化，基数=含税金额，按天×费率计算
 INSERT INTO financial_expense_config
   (config_code, config_name, config_type, rate_value, rate_unit, base_type, calc_method, effective_date, status,
 tenant_id)
 VALUES
   ('INTEREST_RATE_SELF', '自有资金垫资利率', 1, 0.18, 'year', 1, 1, '2024-01-01', 1, '000000');

 -- 银行垫资利率（如需区分）
 INSERT INTO financial_expense_config
   (config_code, config_name, config_type, rate_value, rate_unit, base_type, calc_method, effective_date, status,
 tenant_id)
 VALUES
   ('INTEREST_RATE_BANK', '银行垫资利率', 1, 0.12, 'year', 1, 1, '2024-01-01', 1, '000000');

 -- 通道费：0.5元/吨/天，30天免费期，按阶梯步进
 INSERT INTO financial_expense_config
   (config_code, config_name, config_type, rate_value, rate_unit, base_type, calc_method, tier_rules, effective_date,
  status, tenant_id)
 VALUES
   ('CHANNEL_FEE', '通道费', 2, 0.5, 'day', 3, 2,
    '[{"minDays":0,"maxDays":30,"rate":0},{"minDays":31,"maxDays":9999,"rate":0.5}]',
    '2024-01-01', 1, '000000');

 -- 贴息率：2.3%年化，按360天基准
 INSERT INTO financial_expense_config
   (config_code, config_name, config_type, rate_value, rate_unit, base_type, calc_method, effective_date, status,
 tenant_id)
 VALUES
   ('SUBSIDY_RATE', '贴息率', 3, 0.023, 'year', 1, 1, '2024-01-01', 1, '000000');

 6. 字段说明：
 | 字段        | 取值                                   | 说明     |
 |-------------|----------------------------------------|----------|
 | config_type | 1=垫资利率, 2=通道费, 3=贴息, 4=物流费 | 配置类型 |
 | rate_unit   | year=年化, month=月, day=日            | 费率单位 |
 | base_type   | 1=含税金额, 2=不含税金额, 3=数量(吨)   | 计算基数 |
 | calc_method | 1=按天×费率, 2=阶梯步进, 3=固定金额    | 计算方式 |


 ---
 Phase 2: 后端开发

 任务清单：

 7. Entity 扩展 (FinancialSettlement.java)
   - 添加垫资相关字段（advanceType, advanceAmount, advanceDays, interestAmount 等）
   - 添加公式快照字段 formulaSnapshot
 2. 新建 Entity (FinancialSettlementExpense.java)
   - 继承 TenantEntity
   - 字段：pid, expenseType, expenseName, seqNo, qty, unitPrice, days, amount, taxRate, taxAmount, amountWithoutTax,
 sourceDocType, sourceDocNo, sourceDocId, formulaSnapshot, remark
   - seqNo 由后端自动生成（同类型递增）
 3. 新建 Entity (FinancialExpenseConfig.java)
   - 费率配置实体
 4. Bo/Vo 扩展
   - FinancialSettlementBo 添加 expenseList 字段
   - FinancialSettlementVo 添加对应展示字段
 5. Mapper 新增
   - FinancialSettlementExpenseMapper 继承 BaseMapperPlus
   - FinancialExpenseConfigMapper 继承 BaseMapperPlus
 6. Service 扩展 (FinancialSettlementService.java)
   - 扩展 insertByBo/updateByBo 处理费用明细
   - 扩展 queryById 查询费用明细
   - 新增 calculateAdvanceInterest 方法
   - 新增 validateBeforeSubmit 方法
 7. 新建 Service (ExpenseCalculationEngine.java)
   - 利息计算逻辑
   - 通道费计算逻辑
   - 贴息计算逻辑
   - 公式快照生成
 8. Controller 扩展 (FinancialSettlementController.java)
   - POST /calculateInterest - 计算利息
   - GET /{id}/expense - 查询费用明细
   - POST /{id}/expense - 保存费用明细

 ---
 Phase 3: 前端开发

 任务清单：

 1. API 扩展 (api/supplychain/financial/settlement.ts)
 export function calculateInterest(data) { ... }
 export function getExpenseList(id) { ... }
 export function saveExpenseList(id, data) { ... }
 2. 新建 API (api/supplychain/financial/settlementExpense.ts)
 // 费用明细独立 API（如需要）
 3. 新建编辑页 (views/supplychain/financial/settlement/edit.vue)
   - 参考 payment/edit.vue 布局
   - FlexEdit 上下分割
   - 上部：基本信息 + 垫资信息 + 计算按钮
   - 下部：Tab 切换（商品明细 / 费用明细）
   - 底部：FooterButton
 4. 列表页扩展 (views/supplychain/financial/settlement/index.vue)
   - 添加"新增"按钮（跳转 edit 页）
   - 添加"编辑"操作列
 5. 权限/菜单配置
   - 在系统管理 → 菜单管理中添加编辑页菜单
   - 配置权限：financial:settlement:add/edit/remove

 ---
 Phase 4: 审批流联动

 任务清单：

 1. 流程提交校验
   - 在 ProcessEvent 监听器中调用 validateBeforeSubmit
   - 确保公式快照已生成
 2. 状态流转验证
   - DRAFT → WAITING → FINISH
   - 驳回/撤销 → DRAFT
   - 已提交后不可编辑

 ---
 Phase 5: 测试回归

 测试用例：

 1. 利息计算准确性
   - 输入：垫资100万，18%年化，30天
   - 预期：利息 15,000 元
 2. 通道费计算准确性
   - 输入：500吨，35天
   - 预期：通道费 1,250 元（5天 × 500吨 × 0.5元）
 3. 贴息计算准确性
   - 输入：汇票100万，2.3%年化，120天
   - 预期：贴息 7,666.67 元
 4. 并发修改测试
   - 两个用户同时编辑同一单据
   - 预期：后保存者收到"数据已被修改"提示
 5. 审批流测试
   - 无公式快照时提交
   - 预期：提示"请先计算利息"
 6. 租户隔离测试
   - 租户A的结算单不能被租户B查询
 7. 天数边界测试
   - 输入：同日（startDate == endDate）
   - 预期：天数=0，利息=0
 8. 日期校验测试
   - 输入：起日>止日
   - 预期：抛出"计息开始日不能晚于结束日"异常
 9. 配置缺失测试
   - 输入：删除/失效 INTEREST_RATE_SELF 配置
   - 预期：抛出"未找到有效的费率配置"异常
 10. 重算覆盖测试
   - 操作：多次点击"计算利息"后保存
   - 预期：snapshot 正常覆盖，提交校验通过

 ---
 八、关键文件清单

 后端
 ┌────────────┬─────────────────────────────────────────────────────────┬──────┐
 │    类型    │                          文件                           │ 操作 │
 ├────────────┼─────────────────────────────────────────────────────────┼──────┤
 │ Entity     │ financial/domain/entity/FinancialSettlement.java        │ 扩展 │
 ├────────────┼─────────────────────────────────────────────────────────┼──────┤
 │ Entity     │ financial/domain/entity/FinancialSettlementExpense.java │ 新增 │
 ├────────────┼─────────────────────────────────────────────────────────┼──────┤
 │ Entity     │ financial/domain/entity/FinancialExpenseConfig.java     │ 新增 │
 ├────────────┼─────────────────────────────────────────────────────────┼──────┤
 │ Bo         │ financial/domain/bo/FinancialSettlementBo.java          │ 扩展 │
 ├────────────┼─────────────────────────────────────────────────────────┼──────┤
 │ Bo         │ financial/domain/bo/FinancialSettlementExpenseBo.java   │ 新增 │
 ├────────────┼─────────────────────────────────────────────────────────┼──────┤
 │ Vo         │ financial/domain/vo/FinancialSettlementVo.java          │ 扩展 │
 ├────────────┼─────────────────────────────────────────────────────────┼──────┤
 │ Vo         │ financial/domain/vo/FinancialSettlementExpenseVo.java   │ 新增 │
 ├────────────┼─────────────────────────────────────────────────────────┼──────┤
 │ Mapper     │ financial/mapper/FinancialSettlementExpenseMapper.java  │ 新增 │
 ├────────────┼─────────────────────────────────────────────────────────┼──────┤
 │ Service    │ financial/service/FinancialSettlementService.java       │ 扩展 │
 ├────────────┼─────────────────────────────────────────────────────────┼──────┤
 │ Service    │ financial/service/ExpenseCalculationEngine.java         │ 新增 │
 ├────────────┼─────────────────────────────────────────────────────────┼──────┤
 │ Controller │ financial/controller/FinancialSettlementController.java │ 扩展 │
 └────────────┴─────────────────────────────────────────────────────────┴──────┘
 前端
 ┌──────┬─────────────────────────────────────────────────┬──────┐
 │ 类型 │                      文件                       │ 操作 │
 ├──────┼─────────────────────────────────────────────────┼──────┤
 │ 页面 │ views/supplychain/financial/settlement/edit.vue │ 新增 │
 ├──────┼─────────────────────────────────────────────────┼──────┤
 │ API  │ api/supplychain/financial/settlement.ts         │ 扩展 │
 ├──────┼─────────────────────────────────────────────────┼──────┤
 │ API  │ api/supplychain/financial/settlementExpense.ts  │ 新增 │
 └──────┴─────────────────────────────────────────────────┴──────┘
 SQL
 ┌──────────────────────────────────┬────────────────┐
 │               文件               │      说明      │
 ├──────────────────────────────────┼────────────────┤
 │ V1.0.0__extend_settlement.sql    │ 扩展结算单表   │
 ├──────────────────────────────────┼────────────────┤
 │ V1.0.1__create_expense_table.sql │ 创建费用明细表 │
 ├──────────────────────────────────┼────────────────┤
 │ V1.0.2__create_config_table.sql  │ 创建配置表     │
 ├──────────────────────────────────┼────────────────┤
 │ V1.0.3__init_dict.sql            │ 初始化字典     │
 └──────────────────────────────────┴────────────────┘
 ---
 九、并发与幂等策略

 9.1 公式快照锁定机制

 核心原则：后端权威计算，前端仅展示

 前端操作流程：
 1. 用户填写垫资信息 → 点击"计算利息"按钮
 2. 调用后端 /calculateInterest API → 后端返回计算结果 + 公式快照
 3. 前端展示结果（只读）→ 用户确认后保存/提交

 后端校验规则：
 - 保存时：允许无公式快照（草稿状态）
 - 提交审批时：必须有公式快照，否则拒绝提交
 - 审批通过后：公式快照不可修改

 9.2 审批前校验与锁定

 校验时机： 流程提交前（ProcessEvent.submit = true）

 /**
  * 审批前校验 - 在 processHandler 中调用
  */
 public void validateBeforeSubmit(FinancialSettlement settlement) {
     // 1. 状态校验
     if (!BusinessStatusEnum.DRAFT.getCode().equals(settlement.getCheckedStatus())) {
         throw new ServiceException("单据状态不是草稿，无法提交");
     }

     // 2. 垫资信息校验（如有垫资）
     if (settlement.getAdvanceType() != null && settlement.getAdvanceType() > 0) {
         Assert.notNull(settlement.getAdvanceAmount(), "垫资金额不能为空");
         Assert.notNull(settlement.getAdvanceStartDate(), "计息开始日不能为空");
         Assert.notNull(settlement.getAdvanceEndDate(), "计息结束日不能为空");
         Assert.notNull(settlement.getInterestAmount(), "请先点击[计算利息]按钮");
         Assert.notBlank(settlement.getFormulaSnapshot(), "公式快照不能为空，请先计算");
     }

     // 3. 公式快照格式校验
     if (StringUtils.isNotBlank(settlement.getFormulaSnapshot())) {
         validateFormulaSnapshot(settlement.getFormulaSnapshot());
     }

     // 4. 费用明细校验
     List<FinancialSettlementExpense> expenses = expenseMapper.selectByPid(settlement.getId());
     BigDecimal expenseTotal = expenses.stream()
         .map(FinancialSettlementExpense::getAmount)
         .filter(Objects::nonNull)
         .reduce(BigDecimal.ZERO, BigDecimal::add);

     // 5. 费用合计一致性校验
     BigDecimal settlementExpense = settlement.getTotalExpenseAmount() != null
         ? settlement.getTotalExpenseAmount() : BigDecimal.ZERO;
     if (settlementExpense.compareTo(expenseTotal) != 0) {
         throw new ServiceException("费用明细合计(" + expenseTotal + ")与主表(" + settlementExpense +
 ")不一致，请重新保存");
     }
 }

 /**
  * 审批后锁定 - 禁止编辑
  */
 @EventListener(condition = "#processEvent.flowCode.startsWith('financial_settlement')")
 public void processHandler(ProcessEvent processEvent) {
     FinancialSettlement settlement = baseMapper.selectById(Long.valueOf(processEvent.getBusinessId()));

     // 提交时校验
     if (processEvent.getSubmit()) {
         validateBeforeSubmit(settlement);
         settlement.setCheckedStatus(BusinessStatusEnum.WAITING.getCode());
     }

     // 审批通过：锁定
     if (BusinessStatusEnum.FINISH.getStatus().equals(processEvent.getStatus())) {
         settlement.setCheckedStatus(BusinessStatusEnum.FINISH.getCode());
         // 触发后续业务（商户余额、发票关联等）
         afterApproveFunc(settlement);
     }

     // 驳回/撤销：回到草稿
     if (BusinessStatusEnum.BACK.getStatus().equals(processEvent.getStatus())
         || BusinessStatusEnum.CANCEL.getStatus().equals(processEvent.getStatus())) {
         settlement.setCheckedStatus(BusinessStatusEnum.DRAFT.getCode());
     }

     baseMapper.updateById(settlement);
 }

 编辑保护：已提交/已审批单据不可编辑
 @Override
 public void updateByBo(FinancialSettlementBo bo) {
     FinancialSettlement entity = baseMapper.selectById(bo.getId());

     // 只有草稿状态可编辑
     if (!BusinessStatusEnum.DRAFT.getCode().equals(entity.getCheckedStatus())) {
         throw new ServiceException("单据已提交审批，不允许编辑");
     }

     // ... 正常更新逻辑
 }

 @Override
 public void deleteByIds(Collection<Long> ids) {
     // 校验所有单据都是草稿状态
     List<FinancialSettlement> list = baseMapper.selectBatchIds(ids);
     for (FinancialSettlement settlement : list) {
         if (!BusinessStatusEnum.DRAFT.getCode().equals(settlement.getCheckedStatus())) {
             throw new ServiceException("单据[" + settlement.getDocNo() + "]已提交，不允许删除");
         }
     }

     // ... 正常删除逻辑
 }

 9.3 并发保存幂等

 并发控制方案：状态 + updateTime 校验

 决策：当前框架 BaseEntity 无 version 字段，采用状态+时间戳校验

 前后端 updateTime 传递：
 // 前端：查询时保存 updateTime
 const form = ref<SettlementForm>({
   id: undefined,
   updateTime: undefined,  // 保存查询时的 updateTime
   // ... 其他字段
 });

 // 查询详情时保存
 const getDetail = async (id: number) => {
   const res = await getSettlement(id);
   form.value = res.data;
   form.value.updateTime = res.data.updateTime;  // 保存时间戳
 };

 // 提交时传回
 const submitForm = async () => {
   await updateSettlement({
     ...form.value,
     updateTime: form.value.updateTime  // 传回时间戳
   });
 };

 后端校验：
 @Transactional
 public void updateByBo(FinancialSettlementBo bo) {
     FinancialSettlement entity = baseMapper.selectById(bo.getId());

     // 1. 状态校验：只有草稿状态可修改
     if (!BusinessStatusEnum.DRAFT.getCode().equals(entity.getCheckedStatus())) {
         throw new ServiceException("单据已提交审批，不允许修改");
     }

     // 2. 时间戳校验：前端传回 updateTime，与数据库比对
     if (bo.getUpdateTime() != null && entity.getUpdateTime() != null) {
         // 比较到秒级（避免毫秒精度问题）
         long boTime = bo.getUpdateTime().getTime() / 1000;
         long entityTime = entity.getUpdateTime().getTime() / 1000;
         if (boTime != entityTime) {
             throw new ServiceException("数据已被其他用户修改，请刷新后重试");
         }
     }

     // 3. 正常更新（updateTime 由 MyBatis-Plus 自动填充）
     FinancialSettlement updateEntity = MapstructUtils.convert(bo, FinancialSettlement.class);
     baseMapper.updateById(updateEntity);
 }

 Bo 字段添加：
 // FinancialSettlementBo.java 添加
 private Date updateTime;  // 前端传回的时间戳，用于并发校验

 9.4 重复计算防护

 // 计算利息接口幂等
 public FinancialSettlementVo calculateAdvanceInterest(FinancialSettlementBo bo) {
     // 每次计算都生成新的公式快照（覆盖旧值）
     // 公式快照包含时间戳和操作人，确保可追溯

     String snapshot = buildFormulaSnapshot(bo, result);
     // snapshot 包含: calculatedAt, calculatedBy, 完整计算参数

     bo.setFormulaSnapshot(snapshot);
     return MapstructUtils.convert(bo, FinancialSettlementVo.class);
 }

 ---
 十、复用点具体化

 10.1 后端复用现有实现
 ┌────────────────┬──────────────────────┬────────────────────────────────────────┐
 │    现有组件    │         位置         │                复用方式                │
 ├────────────────┼──────────────────────┼────────────────────────────────────────┤
 │ BaseMapperPlus │ ruoyi-common-mybatis │ Expense Mapper 继承此基类              │
 ├────────────────┼──────────────────────┼────────────────────────────────────────┤
 │ TenantEntity   │ ruoyi-common-tenant  │ Expense Entity 继承此基类              │
 ├────────────────┼──────────────────────┼────────────────────────────────────────┤
 │ @AutoMapper    │ MapStruct            │ Bo/Vo 自动转换                         │
 ├────────────────┼──────────────────────┼────────────────────────────────────────┤
 │ 逻辑删除       │ del_flag 字段        │ 已在 TenantEntity 中                   │
 ├────────────────┼──────────────────────┼────────────────────────────────────────┤
 │ 审批流挂载     │ ProcessEvent 监听    │ 复用现有 financial_settlement 流程代码 │
 ├────────────────┼──────────────────────┼────────────────────────────────────────┤
 │ 编号生成       │ DocNoGenerator       │ 费用表无需编号（明细行）               │
 └────────────────┴──────────────────────┴────────────────────────────────────────┘
 10.2 Mapper 扩展对齐

 现有 FinancialSettlementMapper：
 public interface FinancialSettlementMapper
     extends BaseMapperPlus<FinancialSettlement, FinancialSettlementVo> {
     // 继承 BaseMapperPlus 的所有方法
 }

 新增 FinancialSettlementExpenseMapper：
 public interface FinancialSettlementExpenseMapper
     extends BaseMapperPlus<FinancialSettlementExpense, FinancialSettlementExpenseVo> {

     // 按结算单ID查询费用列表
     default List<FinancialSettlementExpenseVo> selectByPid(Long pid) {
         return selectVoList(Wrappers.<FinancialSettlementExpense>lambdaQuery()
             .eq(FinancialSettlementExpense::getPid, pid)
             .orderByAsc(FinancialSettlementExpense::getExpenseType));
     }

     // 批量删除
     default int deleteByPid(Long pid) {
         return delete(Wrappers.<FinancialSettlementExpense>lambdaQuery()
             .eq(FinancialSettlementExpense::getPid, pid));
     }
 }

 10.3 Service 扩展对齐

 现有 FinancialSettlementService 需扩展的方法：

 // 在 insertByBo/updateByBo 中增加费用明细处理
 @Override
 @Transactional
 public void insertByBo(FinancialSettlementBo bo) {
     // 1. 保存主表（原有逻辑）
     super.insertByBo(bo);

     // 2. 保存费用明细（新增）
     if (CollUtil.isNotEmpty(bo.getExpenseList())) {
         saveExpenseList(bo.getId(), bo.getExpenseList());
     }
 }

 // 在 queryById 中增加费用明细查询
 @Override
 public FinancialSettlementVo queryById(Long id) {
     FinancialSettlementVo vo = super.queryById(id);

     // 查询费用明细
     vo.setExpenseList(expenseMapper.selectByPid(id));

     return vo;
 }

 10.4 前端扩展对齐

 现有页面结构：
 - views/supplychain/financial/settlement/index.vue - 列表页（已有）
 - views/supplychain/financial/settlement/edit.vue - 编辑页（需新增，无现有页面）

 决策：新建编辑页
 - 当前系统无 settlement/edit.vue，需全新创建
 - 参考同模块 payment/edit.vue 布局风格
 - 沿用现有权限命名规范

 权限/路由命名对齐（沿用现有规范）：
 // 现有权限（保留）
 'financial:settlement:list'    // 列表查询
 'financial:settlement:query'   // 详情查询
 'financial:settlement:joint'   // 联查
 'financial:settlement:export'  // 导出

 // 需新增权限（与其他单据一致）
 'financial:settlement:add'     // 新增
 'financial:settlement:edit'    // 编辑
 'financial:settlement:remove'  // 删除

 路由配置（在菜单管理中添加）：
 // 父菜单：财务管理 - 结算管理
 {
   path: 'settlement',
   name: 'Settlement',
   component: () => import('@/views/supplychain/financial/settlement/index.vue'),
   meta: { title: '结算单', icon: 'document' }
 }

 // 编辑页路由（隐藏菜单）
 {
   path: 'settlement/edit/:id?',
   name: 'SettlementEdit',
   component: () => import('@/views/supplychain/financial/settlement/edit.vue'),
   meta: { title: '结算单编辑', activeMenu: '/finance/settlementMgr/settlement' },
   hidden: true
 }

 菜单配置SQL（在系统管理-菜单管理中执行）：
 -- 获取父菜单ID（结算单列表页）
 -- 假设父菜单ID为 @parent_id

 -- 新增按钮权限
 INSERT INTO sys_menu (menu_name, parent_id, order_num, path, component, menu_type, perms, icon, status, tenant_id)
 VALUES ('结算单新增', @parent_id, 2, '', '', 'F', 'financial:settlement:add', '', '0', '000000');

 INSERT INTO sys_menu (menu_name, parent_id, order_num, path, component, menu_type, perms, icon, status, tenant_id)
 VALUES ('结算单编辑', @parent_id, 3, '', '', 'F', 'financial:settlement:edit', '', '0', '000000');

 INSERT INTO sys_menu (menu_name, parent_id, order_num, path, component, menu_type, perms, icon, status, tenant_id)
 VALUES ('结算单删除', @parent_id, 4, '', '', 'F', 'financial:settlement:remove', '', '0', '000000');

 API 扩展（settlement.ts）：
 // 现有
 export function listSettlement(query) { ... }

 // 需新增
 export function getSettlement(id: number) { ... }
 export function addSettlement(data: object) { ... }
 export function updateSettlement(data: object) { ... }
 export function delSettlement(ids: string) { ... }
 export function calculateInterest(data: object) { ... }
 export function getExpenseList(id: number) { ... }
 export function saveExpenseList(id: number, data: object[]) { ... }

 10.5 编辑页设计（参考 payment/edit.vue）

 ┌─────────────────────────────────────────────────────────────┐
 │  FlexEdit (上下分割布局)                                     │
 ├─────────────────────────────────────────────────────────────┤
 │  上部: 基本信息卡片                                          │
 │  ├─ 单据编号、单据日期、供应商                               │
 │  ├─ 垫资类型、垫资金额、计息起止日                           │
 │  ├─ [计算利息] 按钮 → 显示：天数、利率、利息金额             │
 │  └─ 通道费、贴息（根据垫资类型显示）                         │
 ├─────────────────────────────────────────────────────────────┤
 │  下部: Tab 切换                                              │
 │  ├─ Tab1: 商品明细（现有 detail 表）                        │
 │  └─ Tab2: 费用明细（新增 expense 表）                       │
 │       ├─ [添加费用] 按钮                                     │
 │       └─ 费用类型、数量、单价、天数、金额、备注              │
 ├─────────────────────────────────────────────────────────────┤
 │  底部: FooterButton (保存/提交/返回)                         │
 └─────────────────────────────────────────────────────────────┘

 ---
 十一、实施注意事项

 11.1 数值精度规范
 ┌──────────┬─────────┬──────────┬────────────────────┐
 │ 字段类型 │  精度   │ 舍入模式 │        说明        │
 ├──────────┼─────────┼──────────┼────────────────────┤
 │ 金额     │ 2位小数 │ HALF_UP  │ 利息、费用、合计等 │
 ├──────────┼─────────┼──────────┼────────────────────┤
 │ 日利率   │ 6位小数 │ HALF_UP  │ interestRate 字段  │
 ├──────────┼─────────┼──────────┼────────────────────┤
 │ 数量     │ 3位小数 │ HALF_UP  │ qty 字段           │
 ├──────────┼─────────┼──────────┼────────────────────┤
 │ 单价     │ 6位小数 │ HALF_UP  │ unitPrice 字段     │
 └──────────┴─────────┴──────────┴────────────────────┘
 // 数值计算示例
 BigDecimal interest = principal
     .multiply(annualRate)
     .divide(BigDecimal.valueOf(360), 6, RoundingMode.HALF_UP)
     .multiply(BigDecimal.valueOf(days))
     .setScale(2, RoundingMode.HALF_UP);

 11.2 税基确认
 ┌──────────┬──────────┬──────────┬────────────────────────┐
 │ 费用类型 │   税基   │ 税率字段 │          说明          │
 ├──────────┼──────────┼──────────┼────────────────────────┤
 │ 垫资利息 │ 含税金额 │ 暂不计算 │ 后续可扩展             │
 ├──────────┼──────────┼──────────┼────────────────────────┤
 │ 贴息     │ 含税金额 │ 暂不计算 │ 后续可扩展             │
 ├──────────┼──────────┼──────────┼────────────────────────┤
 │ 通道费   │ 数量(吨) │ 暂不计算 │ 后续可扩展             │
 ├──────────┼──────────┼──────────┼────────────────────────┤
 │ 物流费用 │ 用户填写 │ 保留字段 │ taxRate/taxAmount 置零 │
 └──────────┴──────────┴──────────┴────────────────────────┘
 物流费用的税率/税额字段保留，本期暂置零；若后续需要税额计算，再明确单价含/不含税口径

 11.3 配置表初始化检查

 必须初始化的配置：
 -- 检查配置是否存在
 SELECT config_code, rate_value, rate_unit, base_type, calc_method, tier_rules
 FROM financial_expense_config
 WHERE config_code IN ('INTEREST_RATE_SELF', 'INTEREST_RATE_BANK', 'CHANNEL_FEE', 'SUBSIDY_RATE')
   AND status = 1 AND del_flag = '0';

 通道费 tier_rules JSON schema：
 [
   {"minDays": 0, "maxDays": 30, "rate": 0},
   {"minDays": 31, "maxDays": 9999, "rate": 0.5}
 ]

 11.4 前端注意事项

 - otherExpensesAmount 字段设为只读（disabled）
 - 费用明细 Tab 才可编辑费用
 - 保存时发送 expenseList，不传 seqNo（后端自动生成）
 - 查询详情后立即存储 updateTime，提交时回传
 - 编辑页菜单设为 hidden: true，保留 activeMenu 高亮

 11.5 日志/审计

 - 计算利息接口记录：计算人、计算时间、输入参数、输出结果
 - 公式快照包含：version、calculatedAt、calculatedBy、calculatedByName
 - 允许重复计算覆盖旧快照（幂等）

 ---
 十二、验证清单

 口径验收

 - 垫资利息口径已冻结（含验收算例）
 - 通道费口径已确认（30天免费期 + 0.5元/吨/天）
 - 贴息口径已确认（2.3%年化，360天基准）
 - 物流费用口径已冻结（含单价和验收算例）

 技术实施

 - 数据库迁移成功（ALTER TABLE + 新表）
 - Entity/Bo/Vo 字段正确（含 @AutoMapper）
 - Mapper 继承 BaseMapperPlus
 - Service 扩展 insertByBo/updateByBo/queryById
 - Controller 新增计算/费用明细接口
 - 前端编辑页新增（参考 payment/edit.vue）
 - 权限/路由配置对齐现有命名

 业务逻辑

 - 利息计算准确（与验收算例一致）
 - 通道费计算准确（与验收算例一致）
 - 贴息计算准确（与验收算例一致）
 - 费用明细CRUD正常
 - 公式快照JSON格式正确
 - 审批前校验完整
 - 提交后公式快照锁定

 并发与隔离

 - 乐观锁防止并发修改
 - 跨租户数据隔离
 - 逻辑删除功能正常
 - 重复计算幂等
